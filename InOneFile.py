is_trace_on = 1class Registry:	NOT_PRESENT = "-"		def __init__(self):		self.value = []		self.index = {}		def encode(self, value):		if not self.index.has_key(value):			self.index[value] = len(self.value)			self.value.append(value)		return 1L << self.index[value]		def decode(self, bits):		return [			self.value[i]			for i in range(len(self.value))			if bits & (1L << i) != 0		]Registry.instance = Registry()Registry.instance.encode(Registry.NOT_PRESENT)class Scope:	# map each variable from name to range bits	def __init__(self):		self.variable = {}		self.registry = Registry.instance		def deepcopy(self, scope = None):		if scope == None:			scope = Scope()		scope.variable = self.variable.copy()		scope.registry = self.registry		return scope		def add_variable_value(self, name, value):		self.variable[name] = self.variable.get(name, OL) | self.registry.encode(value)		def set_variable(self, name, range):		self.variable[name] = reduce(			lambda x, y, s=self:				x | s.registry.encode(y),			range,			0)		def set_variable_code(self, name, code):		self.variable[name] = code		def get_variable(self, name):		return self.variable[name]		def get_variable_code(self, name):		return self.variable.get(name, 0L)		def get_variable_values(self, name):		r = Registry.instance		return r.decode(self.variable.get(name, 0L))class Symbol:	START_SYMBOL_NAME = "S"		def __init__(self, category, dictionary, scope=None):		"""		The dictionary maps feature names to variable names.		Each variable must be defined in the associated scope before use.		"""		self.category = category		self.features = 0L		self.feature = {}		self.registry = Registry.instance		self.scope = scope		for feature in dictionary.keys():			self.set_feature_variable(feature, dictionary[feature])		def get_category(self):		return self.category		def deepcopy(self):		copy = Symbol(self.category, {}, self.scope)		copy.features = self.features		copy.feature = self.feature.copy()		copy.registry = self.registry		return copy		def set_feature_variable(self, feature, variable):		self.features = self.features | self.registry.encode(feature)		self.feature[feature] = variable		def get_feature_variable(self, feature):		return self.feature[feature]		def get_feature_values(self, feature):		return self.scope.get_variable_values(self.get_feature_variable(feature))		def get_feature_code(self, feature):		return self.scope.get_variable_code(self.get_feature_variable(feature))		def reset_feature_code(self, feature, code):		variable = self.get_feature_variable(feature)		if variable == None:			raise ValueError		return self.scope.set_variable_code(variable, code)		def get_scope(self):		return self.scope		def set_scope(self, scope):		self.scope = scope		def resolve(self, symbol):		"""		Constituents of rules don't act the same for feature matching		as constituents in the agenda do. This method acts appropriately		for the case that the "self" constituent is in an arc, while the		"symbol" constituent is from the agenda.				It is only necessary to examine features that are present in this, the arc constituent.		When the other constituent does not mention one of those features,		the other constituent is assigned a value of "-" (not present) for that feature.		If, for any feature, the other constituent has a value that is not allowed		by this constituent's value, then the two constituents have no intersection		and cannot be resolved.				Here is another important asymmetry:		When our two variables intersect, we'll update the value of the variable in my scope.		"""				if self.category != symbol.category:			raise ValueError, 'Symbols do not have the same category'				our_features = self.features & symbol.features		my_features = self.features & ~symbol.features				for feature in self.registry.decode(our_features):			yours = symbol.get_feature_code(feature)			self.resolve_feature_values(feature, yours)		for feature in self.registry.decode(my_features):			yours = self.registry.encode(Registry.NOT_PRESENT)			self.resolve_feature_values(feature, yours)			def resolve_feature_values(self, feature, yours):		mine = self.get_feature_code(feature)		ours = mine & yours		if ours == 0L:			raise ValueError, 'Symbols do not have the same feature values'		elif ours == mine:			pass		else:			self.reset_feature_code(feature, ours)			def __str__(self):		def feature_value_str(symbol, feature):			code = symbol.get_feature_code(feature)			if code == -1L:				return "%s: %s" % (feature, symbol.get_feature_variable(feature))			else:				return "%s: %s" % (feature, symbol.get_feature_values(feature))					return "%s%s" % (self.category, map( lambda x, s=self, f=feature_value_str: f(s, x), self.feature.keys() ))		class Lexical(Symbol, Scope):	def __init__(self, category, dictionary):		Symbol.__init__(self, category, dictionary, self)		Scope.__init__(self)class Lexicon:	def __init__(self):		self.data = { }		# interpretations are instances of Lexical	def add_word(self, word, interpretations):		self.data[word] = interpretations		def get_interpretations(self, word):		return self.data[word]class Rule(Scope):	def __init__(self, mother, children):		Scope.__init__(self)		self.set_mother(mother)		self.set_children(children)		def set_mother(self, mother):		mother.set_scope(self)		self.mother = mother		def get_mother(self):		return self.mother		def set_children(self, children):		for child in children:			child.set_scope(self)		self.children = children		def get_children(self):		return self.children		def get_child(self, i):		return self.get_children()[i]		def size(self):		return len(self.get_children())		def deepcopy(self):		mother = self.get_mother().deepcopy()		children = map(lambda x: x.deepcopy(), self.get_children())				copy = Rule(mother, children)				Scope.deepcopy(self, copy)				# I haven't thought through whether the next lines are necessary. They don't hurt.		copy.get_mother().set_scope(copy)		for child in copy.get_children():			child.set_scope(copy)					return copy		def __str__(self):		return str(self.get_mother()) + " ->" + reduce(lambda x, y: x + " " + str(y), self.get_children())class Grammar:	def __init__(self):		self.data = []		def add_rule(self, rule):		self.data.append(rule)		def add_new_rule(self, mother, children):		self.add_rule(Rule(mother, children))		def get_rules(self):		return self.data				class Constituent:	def __init__(self, symbol, start, end):		self.set_symbol(symbol)		self.set_start(start)		self.set_end(end)		def set_symbol(self, symbol):		self.symbol = symbol		def get_symbol(self):		return self.symbol		def set_start(self, start):		self.start = start		def get_start(self):		return self.start		def set_end(self, end):		self.end = end		def get_end(self):		return self.end		def __str__(self):		return "%s from %d to %d" % (self.get_symbol(), self.get_start(), self.get_end())class Agenda:	def __init__(self):		self.data = []		def add_constituent(self, constituent):		self.data.append(constituent)		def add_constituent(self, symbol, start, end):		self.data.append(Constituent(symbol, start, end))		def add_alternatives(self, list, position):		map (			lambda symbol, p=position, me=self : me.add_constituent(symbol, p, p+1),			list		)		def next_constituent(self):		constituent = self.data.pop(0)		if is_trace_on:			print "Entering " + str(constituent)		return constituent		def size(self):		return len(self.data)class Arc:	def __init__(self, rule, progress, start, end):		self.set_rule(rule.deepcopy())		self.set_progress(progress)		self.set_start(start)		self.set_end(end)		def set_rule(self, rule):		self.rule = rule		def get_rule(self):		return self.rule		def set_progress(self, progress):		self.progress = progress		def get_progress(self):		return self.progress		def set_start(self, start):		self.start = start		def get_start(self):		return self.start		def set_end(self, end):		self.end = end		def get_end(self):		return self.end		def get_children(self):		return self.get_rule().get_children()		def get_child(self, i):		return self.get_rule().get_child(i)		def get_mother(self):		return self.get_rule().get_mother()		def next_symbol(self):		if self.get_progress() >= self.size():			return None		return self.get_child(self.get_progress())		def size(self):		return self.get_rule().size()		def __str__(self):		children1 = reduce(lambda x, y: x + " " + str(y), self.get_children()[0:self.get_progress()], "")		children2 = reduce(lambda x, y: x + " " + str(y), self.get_children()[self.get_progress():], "")		return "%s ->%s o%s from %d to %d" % (self.get_mother(), children1, children2, self.get_start(), self.get_end())class Chart:	def __init__(self, grammar, agenda):		self.data = []		self.grammar = grammar		self.agenda = agenda		def extend_arcs(self, constituent):		for arc in self.data:			if arc.get_end() == constituent.get_start() and arc.next_symbol().get_category() == constituent.get_symbol().get_category():				new_arc = Arc(arc.get_rule(), arc.get_progress(), arc.get_start(), constituent.get_end())				try:					new_arc.next_symbol().resolve(constituent.get_symbol())					new_arc.set_progress(new_arc.get_progress() + 1)					self.introduce(new_arc)					if new_arc.get_progress() == new_arc.size():						self.agenda.add_constituent(new_arc.get_mother(), new_arc.get_start(), new_arc.get_end())				except ValueError, v:					print v		def introduce(self, arc):		if is_trace_on:			print "    An arc can be extended " + str(arc)		self.data.append(arc)		self.introduce_symbol(arc.next_symbol(), arc.get_end())		def introduce_symbol(self, symbol, position):		if symbol == None:			return		if is_trace_on:			print "Introducing symbol " + str(symbol)		is_first = 1		for rule in self.grammar.get_rules():			if rule.get_mother().get_category() == symbol.get_category():				if is_trace_on and is_first:					print "    Using the top-down rule, new active arcs are added for " + str(symbol)					is_first = 0				self.introduce(Arc(rule, 0, position, position))class Parser:	def parse(self, start_symbol, lexicon, grammar, sentence):		agenda = Agenda()		chart = Chart(grammar, agenda)		chart.introduce_symbol(start_symbol, 0)		position = 0		while position < len(sentence) or agenda.size() > 0:			if agenda.size() == 0:				agenda.add_alternatives(lexicon.get_interpretations(sentence[position]), position)				position = position + 1			chart.extend_arcs(agenda.next_constituent())class SampleParser(Parser):	def test(self):		NP = Lexical("NP", {"AGR": "?x"})		NP.set_variable_code("?x", -1L)				lexicon = Lexicon()				the = Lexical("ART", {"ROOT": "?the", "AGR": "?v"})		the.set_variable("?the", ["the"])		the.set_variable("?v", ["3s", "3p"])		lexicon.add_word("the", [ the ])				dog = Lexical("N", {"ROOT": "?dog1", "AGR": "?3s"})		dog.set_variable("?3s", ["3s"])		dog.set_variable("?dog1", ["DOG1"])		lexicon.add_word("dog", [ dog ])				grammar = Grammar()		r1 = Rule( Symbol("NP", {"AGR": "?a"}), [ Symbol("ART", {"AGR": "?a"}), Symbol("N", {"AGR": "?a"}) ] )		r1.set_variable_code("?a", -1L)		# -1L should be default for any undefined variable that is referenced while constructing		grammar.add_rule(r1)				sentence = [ "the", "dog" ]				self.parse(NP, lexicon, grammar, sentence)	SampleParser().test()print